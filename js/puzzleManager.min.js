export default class PuzzleManager{constructor(e){return createjs?createjs.BitmapData?(this.loadQueue=new createjs.LoadQueue,this.puzzleContainer=new createjs.Container,this.debugContainer=new createjs.Container,this.imageMap=[],this.containers=[],this.dimensionPiece=[],this.dimensionStage=[0,0],this.selectOffset=[0,0],this.moveCount=0,this.moveGrossCount=0,this.solvedPieces=0,this.config=e,this.boundsContainers,this.timeStart,this.timeEnd,this.stage=new createjs.Stage(e.canvasTargetId),void this.loadAssets()):alert("Create JS plugin BitmapData not detected. Please install!"):alert("Create JS Library not detected. Please install!")}initPuzzle(){const{framerate:e,homePosition:t,debug:i,piecesPerRow:n}=this.config,{stage:s,loadQueue:r}=this;if(console.log("IMAGE SIZE : ",r.getResult("main").width,r.getResult("main").height),this.dimensionStage[0]=r.getResult("main").width,this.dimensionStage[1]=r.getResult("main").height,createjs.Touch.enable(s),createjs.Ticker.framerate=e,createjs.Ticker.addEventListener("tick",function(){s.update()}),this.config.reordering&&0===this.config.reordering.length&&!i)for(this.generateRandomPositions();!this.verifyIsSolvable();)console.log("Generated a non solvable puzzle"),this.generateRandomPositions();if(this.config.reordering&&this.config.reordering.length>0){let e=this.config.reordering[t];if(-1===e){let t=Math.pow(n,2);for(let i=0;i<t;i++)if(-1===this.config.reordering.indexOf(i)){e=i;break}}this.config.reordering[t]=-1;for(let t=0;t<this.config.reordering.length;t++)this.config.reordering[t]>e&&(this.config.reordering[t]-=1)}if(this.sliceMap(r.getResult("main")),this.addSlicesToStage(),r.getResult("background")){let e=new createjs.Container;e.addChild(new createjs.Bitmap(r.getResult("background"))),this.stage.addChildAt(e,0)}}generateRandomPositions(){const{homePosition:e,piecesPerRow:t}=this.config;this.config.reordering=[];let i=[];for(let n=0;n<Math.pow(t,2);n++)n!==e&&i.push(n);for(;i.length>0;){let e=i.splice(Math.floor(Math.random()*i.length),1);this.config.reordering.push(e[0])}this.config.reordering.splice(e,0,e)}verifyIsSolvable(){const{reordering:e,piecesPerRow:t,homePosition:i}=this.config;let n=0;for(let t=0;t<e.length;t++){let i=0;for(let s=t+1;s<e.length;s++)e[s]>-1&&(e[t]>e[s]&&n++,e[t]>e[s]&&i++)}Math.floor((Math.pow(t,2)-i-1)/t);if(!this.isEven(t)&&this.isEven(n))return!0;if(this.isEven(t)){let e=Math.floor((Math.pow(t,2)-i-1)/t)+1;if(this.isEven(e)&&!this.isEven(n))return!0;if(!this.isEven(e)&&this.isEven(n))return!0}return!1}isEven(e){return Math.floor(e/2)===e/2}startPuzzle(){const{containers:e}=this;for(let t=0;t<e.length;t++)e[t].addEventListener("mousedown",e=>{this.handleSelectPiece(e)}),e[t].addEventListener("pressmove",e=>{this.handlePressMove(e)}),e[t].addEventListener("pressup",e=>{this.handleDeselect(e)});this.timeStart=new Date}handleSelectPiece(e){let{stage:t,selectOffset:i}=this;i[0]=e.localX,i[1]=e.localY,t.setChildIndex(e.currentTarget,t.numChildren-1),this.calculateDragBounds(e.currentTarget)}handlePressMove(e){let{selectOffset:t,boundsContainers:i,dimensionPiece:n}=this,{puzzleOffset:s}=this.config;e.currentTarget.x=-s[0]+e.stageX-t[0],e.currentTarget.y=-s[1]+e.stageY-t[1],null!==i&&(i[0].x>e.currentTarget.x&&(e.currentTarget.x=i[0].x),i[0].x+i[0].width<e.currentTarget.x+n[0]&&(e.currentTarget.x=i[0].x+i[0].width-n[0]),i[1].y>e.currentTarget.y&&(e.currentTarget.y=i[1].y),i[1].y+i[1].height<e.currentTarget.y+n[1]&&(e.currentTarget.y=i[1].y+i[1].height-n[1]))}handleDeselect(e){let{dimensionPiece:t}=this;const{piecesPerRow:i,onSolvePiece:n}=this.config;if(this.moveGrossCount++,e.currentTarget.x%t[0]<2&&e.currentTarget.y%t[1]<2){e.currentTarget.x=t[0]*Math.floor(e.currentTarget.x/t[0]),e.currentTarget.y=t[1]*Math.floor(e.currentTarget.y/t[1]),this.moveCount++,e.currentTarget.x<0&&(e.currentTarget.x=0),e.currentTarget.y<0&&(e.currentTarget.y=0),this.checkSolved(),Math.floor(e.currentTarget.y/t[1])*i+Math.floor(e.currentTarget.x/t[0])===e.currentTarget.myIndex&&(console.log("Total solved pieces",this.solvedPieces),n&&n())}}getTimeTaken(){return this.timeEnd=new Date,this.timeEnd-this.timeStart}checkSolved(){const{containers:e,dimensionPiece:t}=this,{piecesPerRow:i}=this.config;this.solvedPieces=0;for(let n=0;n<e.length;n++){Math.floor(e[n].y/t[1])*i+Math.floor(e[n].x/t[0])===e[n].myIndex&&this.solvedPieces++}this.solvedPieces===Math.pow(i,2)-1&&this.onSolvePuzzle()}onSolvePuzzle(){const{onSolvePuzzle:e}=this.config;console.log("Completed the game!!!! Completed in "+this.moveGrossCount+" movements & "+this.moveCount+" moves!!","Solved in "+this.getTimeTaken()+"ms");for(let e=0;e<this.containers.length;e++)this.containers[e].removeAllEventListeners();e&&e()}calculateDragBounds(e){const{debug:t}=this.config,{Rectangle:i}=createjs;let{containers:n,dimensionPiece:s,dimensionStage:r}=this,o=new i(e.x+1,0,s[0]-2,r[1]),a=new i(0,e.y+1,r[0],s[1]-2);this.boundsContainers=[a,o];for(let t=0;t<n.length;t++)n[t]===e||(o.intersects(n[t].getTransformedBounds())&&(e.y>n[t].y&&o.y<n[t].y+s[1]?(o.height=o.height-(n[t].y+s[1]-o.y),o.y=n[t].y+s[1]):o.y+o.height>n[t].y&&(o.height=n[t].y-o.y)),a.intersects(n[t].getTransformedBounds())&&(e.x>n[t].x&&a.x<n[t].x+s[0]?(a.width=a.width-(n[t].x+s[0]-a.x),a.x=n[t].x+s[0]):a.x+a.width>n[t].x&&a.x<n[t].x&&(a.width=n[t].x-a.x)));a.x+a.width>r[0]&&(a.width=a.width-(a.x+a.width-r[0])),o.y+o.height>r[1]&&(o.height=o.height-(o.y+o.height-r[1])),t&&this.showDebugPositions()}sliceMap(e){const{BitmapData:t,Rectangle:i,Bitmap:n}=createjs,{dimensionPiece:s,imageMap:r}=this,{piecesPerRow:o,homePosition:a}=this.config;let h=s[0]=e.width/o,l=s[1]=e.height/o,c=new createjs.Point;for(let s=0;s<o;s++)for(let a=0;a<o;a++){let o=new t(null,h,l,0),d=new i(a*h,s*l,h,l);o.copyPixels(e,d,c);let g=new n(o.canvas);r.push(g)}r[a]=null}addSlicesToStage(){const{Container:e,Graphics:t,Shape:i}=createjs,{piecesPerRow:n,reordering:s,debug:r,puzzleOffset:o,onLoad:a}=this.config,{containers:h,stage:l,dimensionPiece:c,imageMap:d,puzzleContainer:g}=this;l.addChild(g),g.x=o[0],g.y=o[1];let u=new t;u.setStrokeStyle(1),u.beginStroke("#333333"),u.drawRect(0,0,c[0],c[1]);for(let t=0;t<n;t++)for(let s=0;s<n;s++)if(s+t*n<Math.pow(n,2)){let o=s+t*n;if(d[o]){let n=new e;n.addChild(d[o]),n.x=s*c[0],n.y=t*c[1];let a=new i(u);n.addChild(a),h.push(n),h[h.length-1].myIndex=o,r&&n.addChild(new createjs.Text("#"+o,"24px Arial","#ff2222")),g.addChild(n)}else;}if(s&&s.length>0)for(let e=0;e<s.length;e++)-1!=s[e]&&(h[s[e]].x=e%n*c[0],h[s[e]].y=Math.floor(e/n)*c[1],h[s[e]].startIndex=e);a?a():this.startPuzzle()}loadAssets(){const{targetImage:e,backgroundImage:t}=this.config;let i=[{id:"main",src:e}];t&&i.push({id:"background",src:t}),this.loadQueue.loadManifest(i),this.loadQueue.on("complete",this.handleLoadComplete,this)}handleLoadComplete(){this.initPuzzle()}showDebugPositions(){const{Graphics:e,Shape:t}=createjs;let{debugContainer:i,boundsContainers:n,puzzleContainer:s}=this,r=new e;r.setStrokeStyle(1),r.beginStroke("#CCCCCC"),r.beginFill("#AA330020"),r.drawRect(n[1].x,n[1].y,n[1].width,n[1].height),r.drawRect(n[0].x,n[0].y,n[0].width,n[0].height),i.removeAllChildren();let o=new t(r);i.addChild(o),s.addChild(i)}};